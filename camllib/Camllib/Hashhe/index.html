<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Hashhe (camllib.Camllib.Hashhe)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">camllib</a> &#x00BB; <a href="../index.html">Camllib</a> &#x00BB; Hashhe</nav><header class="odoc-preamble"><h1>Module <code><span>Camllib.Hashhe</span></code></h1><p>Hash tables and hash functions (extension of standard library module)</p></header><nav class="odoc-toc"><ul><li><a href="#generic-interface">Generic interface</a></li><li><a href="#functorial-interface">Functorial interface</a></li><li><a href="#the-polymorphic-hash-primitive">The polymorphic hash primitive</a></li></ul></nav><div class="odoc-content"><p>Hash tables are hashed association tables, with in-place modification.</p><p>Modified by B. Jeannet: functions <code>map</code>, <code>copy</code> and <code>print</code>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-hashtbl"><a href="#type-hashtbl" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) hashtbl</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-compare"><a href="#type-compare" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a compare</span></span><span> = </span><span>{</span></code><ol><li id="type-compare.hash" class="def record field anchored"><a href="#type-compare.hash" class="anchor"></a><code><span>hash : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int;</span></code></li><li id="type-compare.equal" class="def record field anchored"><a href="#type-compare.equal" class="anchor"></a><code><span>equal : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></li></ol><code><span>}</span></code></div></div><h6 id="generic-interface"><a href="#generic-interface" class="anchor"></a>Generic interface</h6><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) t</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-hashtbl">hashtbl</a></span></span></code></div><div class="spec-doc"><p>The type of hash tables from type <code>'a</code> to type <code>'b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create n</code> creates a new, empty hash table, with initial size <code>n</code>. For best results, <code>n</code> should be on the order of the expected number of elements that will be in the table. The table grows as needed, so <code>n</code> is just an initial guess.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span><span class="keyword">val</span> clear : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Empty a hash table. Use <code>reset</code> instead of <code>clear</code> to shrink the size of the bucket table to its initial size.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span><span class="keyword">val</span> reset : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Empty a hash table and shrink the size of the bucket table to its initial size.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add tbl x y</code> adds a binding of <code>x</code> to <code>y</code> in table <code>tbl</code>. Previous bindings for <code>x</code> are not removed, but simply hidden. That is, after performing <a href="#val-remove"><code>remove</code></a><code> tbl x</code>, the previous binding for <code>x</code>, if any, is restored. (Same behavior as with association lists.)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Return a copy of the given hashtable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>find tbl x</code> returns the current binding of <code>x</code> in <code>tbl</code>, or raises <code>Not_found</code> if no such binding exists.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span><span class="keyword">val</span> find_all : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>find_all tbl x</code> returns the list of all data associated with <code>x</code> in <code>tbl</code>. The current binding is returned first, then the previous bindings, in reverse order of introduction in the table.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem tbl x</code> checks if <code>x</code> is bound in <code>tbl</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>remove tbl x</code> removes the current binding of <code>x</code> in <code>tbl</code>, restoring the previous binding if it exists. It does nothing if <code>x</code> is not bound in <code>tbl</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span><span class="keyword">val</span> replace : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>replace tbl x y</code> replaces the current binding of <code>x</code> in <code>tbl</code> by a binding of <code>x</code> to <code>y</code>. If <code>x</code> is unbound in <code>tbl</code>, a binding of <code>x</code> to <code>y</code> is added to <code>tbl</code>. This is functionally equivalent to <a href="#val-remove"><code>remove</code></a><code> tbl x</code> followed by <a href="#val-add"><code>add</code></a><code> tbl x y</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f tbl</code> applies <code>f</code> to all bindings in table <code>tbl</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to <code>f</code>. The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>fold f tbl init</code> computes <code>(f kN dN ... (f k1 d1 init)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>tbl</code>, and <code>d1 ... dN</code> are the associated values. Each binding is presented exactly once to <code>f</code>. The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f tbl</code> applies <code>f</code> to all bindings in table <code>tbl</code> and creates a new hashtable associating the results of <code>f</code> to the same key type. <code>f</code> receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to <code>f</code>. The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length tbl</code> returns the number of bindings in <code>tbl</code>. Multiple bindings are counted multiply, so <code>length</code> gives the number of times <code>iter</code> calls it first argument.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-statistics"><a href="#type-statistics" class="anchor"></a><code><span><span class="keyword">type</span> statistics</span><span> = <span class="xref-unresolved">Stdlib</span>.Hashtbl.statistics</span><span> = </span><span>{</span></code><ol><li id="type-statistics.num_bindings" class="def record field anchored"><a href="#type-statistics.num_bindings" class="anchor"></a><code><span>num_bindings : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of bindings present in the table. Same value as returned by <code>Hashtbl.length</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-statistics.num_buckets" class="def record field anchored"><a href="#type-statistics.num_buckets" class="anchor"></a><code><span>num_buckets : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of buckets in the table.</p><span class="comment-delim">*)</span></div></li><li id="type-statistics.max_bucket_length" class="def record field anchored"><a href="#type-statistics.max_bucket_length" class="anchor"></a><code><span>max_bucket_length : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Maximal number of bindings per bucket.</p><span class="comment-delim">*)</span></div></li><li id="type-statistics.bucket_histogram" class="def record field anchored"><a href="#type-statistics.bucket_histogram" class="anchor"></a><code><span>bucket_histogram : <span>int array</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Histogram of bucket sizes. This array <code>histo</code> has length <code>max_bucket_length + 1</code>. The value of <code>histo.(i)</code> is the number of buckets whose size is <code>i</code>.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stats"><a href="#val-stats" class="anchor"></a><code><span><span class="keyword">val</span> stats : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-statistics">statistics</a></span></code></div><div class="spec-doc"><p><code>Hashtbl.stats tbl</code> returns statistics about the table <code>tbl</code>: number of buckets, size of the biggest bucket, distribution of buckets by size.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.00.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : 
  <span><span class="optlabel">?first</span>:<span><span>(unit, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit)</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?sep</span>:<span><span>(unit, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit)</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?last</span>:<span><span>(unit, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit)</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?firstbind</span>:<span><span>(unit, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit)</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?sepbind</span>:<span><span>(unit, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit)</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?lastbind</span>:<span><span>(unit, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit)</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><h6 id="functorial-interface"><a href="#functorial-interface" class="anchor"></a>Functorial interface</h6><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HashedType"><a href="#module-type-HashedType" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HashedType/index.html">HashedType</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The input signature of the functor <a href="Make/index.html"><code>Make</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The output signature of the functor <a href="Make/index.html"><code>Make</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-H/index.html">H</a> : <a href="module-type-HashedType/index.html">HashedType</a>) : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-key">key</a> = <a href="Make/argument-1-H/index.html#type-t">H.t</a></span></span></code></div><div class="spec-doc"><p>Functor building an implementation of the hashtable structure. The functor <code>Make</code> returns a structure containing a type <code>key</code> of keys and a type <code>'a t</code> of hash tables associating data of type <code>'a</code> to keys of type <code>key</code>. The operations perform similarly to those of the generic interface, but use the hashing and equality functions specified in the functor argument <code>H</code> instead of generic equality and hashing.</p></div></div><h6 id="the-polymorphic-hash-primitive"><a href="#the-polymorphic-hash-primitive" class="anchor"></a>The polymorphic hash primitive</h6><div class="odoc-spec"><div class="spec value anchored" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hash x</code> associates a positive integer to any value of any type. It is guaranteed that if <code>x = y</code> or <code>Pervasives.compare x y = 0</code>, then <code>hash x = hash y</code>. Moreover, <code>hash</code> always terminates, even on cyclic structures.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash_param"><a href="#val-hash_param" class="anchor"></a><code><span><span class="keyword">val</span> hash_param : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hash_param n m x</code> computes a hash value for <code>x</code>, with the same properties as for <code>hash</code>. The two extra parameters <code>n</code> and <code>m</code> give more precise control over hashing. Hashing performs a depth-first, right-to-left traversal of the structure <code>x</code>, stopping after <code>n</code> meaningful nodes were encountered, or <code>m</code> nodes, meaningful or not, were encountered. Meaningful nodes are: integers; floating-point numbers; strings; characters; booleans; and constant constructors. Larger values of <code>m</code> and <code>n</code> means that more nodes are taken into account to compute the final hash value, and therefore collisions are less likely to happen. However, hashing takes longer. The parameters <code>m</code> and <code>n</code> govern the tradeoff between accuracy and speed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stdcompare"><a href="#val-stdcompare" class="anchor"></a><code><span><span class="keyword">val</span> stdcompare : <span><span class="type-var">'a</span> <a href="#type-compare">compare</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Compare"><a href="#module-Compare" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Compare/index.html">Compare</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
